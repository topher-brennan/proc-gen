// Build script to generate WGSL constants by parsing src/constants.rs
// This creates a single source of truth - edit constants.rs and WGSL gets updated automatically.

use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::Path;

fn main() {
    // Read and parse constants.rs
    let constants_src =
        fs::read_to_string("src/constants.rs").expect("Failed to read src/constants.rs");

    // Parse all constants into a map
    let constants = parse_constants(&constants_src);

    // Extract the values we need for WGSL (evaluating expressions)
    let width = eval_usize(&constants, "WIDTH_HEXAGONS");
    let height = eval_usize(&constants, "HEIGHT_PIXELS");
    let hex_size = eval_f32(&constants, "HEX_SIZE");
    let hex_factor = eval_f32(&constants, "HEX_FACTOR");
    let flow_factor = eval_f32(&constants, "FLOW_FACTOR");
    let max_flow = eval_f32(&constants, "MAX_FLOW");
    let kc = eval_f32(&constants, "KC");
    let ke = eval_f32(&constants, "KE");
    let kd = eval_f32(&constants, "KD");
    let max_slope = eval_f32(&constants, "MAX_SLOPE");
    let max_elevation = eval_f32(&constants, "MAX_ELEVATION");
    let evaporation_factor = eval_f32(&constants, "EVAPORATION_FACTOR");
    let max_evaporation_per_step = eval_f32(&constants, "MAX_EVAPORATION_PER_STEP");
    let abyssal_depth = eval_f32(&constants, "ABYSSAL_PLAINS_MAX_DEPTH");
    let shelf_depth = eval_f32(&constants, "CONTINENTAL_SHELF_DEPTH");
    let ne_basin_min_elevation = eval_f32(&constants, "NE_BASIN_MIN_ELEVATION");

    // Compute BASIN_X_BOUNDARY = TOTAL_SEA_WIDTH + NORTH_DESERT_WIDTH
    let total_sea_width = eval_usize(&constants, "TOTAL_SEA_WIDTH");
    let north_desert_width = eval_usize(&constants, "NORTH_DESERT_WIDTH");
    let basin_x_boundary = total_sea_width + north_desert_width;
    let basin_y_boundary = eval_usize(&constants, "NE_BASIN_HEIGHT");

    // TODO: Figure out how to make these integer types where appropriate.
    let wgsl_constants = format!(
        r#"// Auto-generated by build.rs from src/constants.rs - DO NOT EDIT
// Edit src/constants.rs instead, then rebuild.

const WIDTH: f32 = {width}.0;
const HEIGHT: f32 = {height}.0;
const HEX_SIZE: f32 = {hex_size};
const HEX_FACTOR: f32 = {hex_factor};

const FLOW_FACTOR: f32 = {flow_factor};
const MAX_FLOW: f32 = {max_flow};

const KC: f32 = {kc};
const KE: f32 = {ke};
const KD: f32 = {kd};
const MAX_SLOPE: f32 = {max_slope};
const MAX_ELEVATION: f32 = {max_elevation};

const EVAPORATION_FACTOR: f32 = {evaporation_factor};
const MAX_EVAPORATION_PER_STEP: f32 = {max_evaporation_per_step};
const BASIN_X_BOUNDARY: f32 = {basin_x_boundary}.0;
const BASIN_Y_BOUNDARY: f32 = {basin_y_boundary}.0;
const NE_BASIN_MIN_ELEVATION: f32 = {ne_basin_min_elevation};

const ABYSSAL_PLAINS_MAX_DEPTH: f32 = {abyssal_depth};
const CONTINENTAL_SHELF_DEPTH: f32 = {shelf_depth};
"#,
        hex_size = fmt_float(hex_size),
        hex_factor = fmt_float(hex_factor),
        flow_factor = fmt_float(flow_factor),
        max_flow = fmt_float(max_flow),
        kc = fmt_float(kc),
        ke = fmt_float(ke),
        kd = fmt_float(kd),
        max_slope = fmt_float(max_slope),
        max_elevation = fmt_float(max_elevation),
        evaporation_factor = fmt_float(evaporation_factor),
        max_evaporation_per_step = fmt_float(max_evaporation_per_step),
        ne_basin_min_elevation = fmt_float(ne_basin_min_elevation),
        abyssal_depth = fmt_float(abyssal_depth),
        shelf_depth = fmt_float(shelf_depth),
    );

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated_constants.wgsl");
    fs::write(&dest_path, &wgsl_constants).unwrap();

    // Also write to src/shaders for IDE support
    let src_path = Path::new("src/shaders/generated_constants.wgsl");
    fs::write(src_path, &wgsl_constants).unwrap();

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=src/constants.rs");
}

/// Format a float for WGSL - ensures it always has a decimal point
fn fmt_float(val: f32) -> String {
    let s = format!("{}", val);
    if s.contains('.') || s.contains('e') || s.contains('E') {
        s
    } else {
        format!("{}.0", s)
    }
}

/// Parse all `pub const NAME: TYPE = EXPR;` declarations from the source
/// Handles multi-line constants by accumulating lines until the semicolon
fn parse_constants(src: &str) -> HashMap<String, String> {
    let mut constants = HashMap::new();
    let mut lines = src.lines().peekable();

    while let Some(line) = lines.next() {
        let line = line.trim();
        if line.starts_with("pub const ") {
            // Accumulate the full declaration (may span multiple lines)
            let mut full_line = line.to_string();
            while !full_line.contains(';') {
                if let Some(next) = lines.next() {
                    full_line.push(' ');
                    full_line.push_str(next.trim());
                } else {
                    break;
                }
            }

            // Extract: pub const NAME: TYPE = EXPR;
            if let Some(rest) = full_line.strip_prefix("pub const ") {
                if let Some(colon_pos) = rest.find(':') {
                    let name = rest[..colon_pos].trim();
                    if let Some(eq_pos) = rest.find('=') {
                        let mut expr = rest[eq_pos + 1..].trim().to_string();
                        // First strip inline comments
                        if let Some(comment_pos) = expr.find("//") {
                            expr = expr[..comment_pos].trim().to_string();
                        }
                        // Then strip trailing semicolon
                        expr = expr.trim_end_matches(';').trim().to_string();
                        constants.insert(name.to_string(), expr);
                    }
                }
            }
        }
    }

    constants
}

/// Evaluate an expression that should result in f32
fn eval_f32(constants: &HashMap<String, String>, name: &str) -> f32 {
    let expr = constants
        .get(name)
        .unwrap_or_else(|| panic!("Constant {} not found", name));
    eval_f32_expr(constants, expr)
}

/// Evaluate an expression that should result in usize
fn eval_usize(constants: &HashMap<String, String>, name: &str) -> usize {
    let expr = constants
        .get(name)
        .unwrap_or_else(|| panic!("Constant {} not found", name));
    eval_usize_expr(constants, expr)
}

/// Recursively evaluate an f32 expression
fn eval_f32_expr(constants: &HashMap<String, String>, expr: &str) -> f32 {
    let expr = expr.trim();

    // Handle parenthesized expressions like "(CONST as f32)" or "(expr)"
    if expr.starts_with('(') && expr.ends_with(')') {
        let inner = &expr[1..expr.len() - 1];
        // Check if the parens wrap a complete expression (balanced)
        let mut depth = 0;
        let mut is_wrapper = true;
        for c in inner.chars() {
            match c {
                '(' => depth += 1,
                ')' => {
                    depth -= 1;
                    if depth < 0 {
                        is_wrapper = false;
                        break;
                    }
                }
                _ => {}
            }
        }
        if is_wrapper && depth == 0 {
            return eval_f32_expr(constants, inner);
        }
    }

    // Handle `as f32` casts ONLY if at the end of expression
    if expr.ends_with(" as f32") {
        let inner = expr[..expr.len() - 7].trim(); // 7 = " as f32".len()
                                                   // Strip outer parens if present
        let inner = if inner.starts_with('(') && inner.ends_with(')') {
            &inner[1..inner.len() - 1]
        } else {
            inner
        };
        // Try evaluating as usize first, then convert
        if let Ok(val) = try_eval_usize_expr(constants, inner) {
            return val as f32;
        }
        return eval_f32_expr(constants, inner);
    }

    // Handle `as usize` casts - evaluate inner as f32 and cast
    if expr.ends_with(" as usize") {
        let inner = expr[..expr.len() - 9].trim(); // 9 = " as usize".len()
                                                   // Strip outer parens if present
        let inner = if inner.starts_with('(') && inner.ends_with(')') {
            &inner[1..inner.len() - 1]
        } else {
            inner
        };
        return eval_f32_expr(constants, inner).floor();
    }

    // Handle binary operations (find lowest precedence operator outside parens)
    if let Some((left, op, right)) = split_binary_op(expr) {
        let l = eval_f32_expr(constants, left);
        let r = eval_f32_expr(constants, right);
        return match op {
            '+' => l + r,
            '-' => l - r,
            '*' => l * r,
            '/' => l / r,
            _ => panic!("Unknown operator: {}", op),
        };
    }

    // Try parsing as a literal
    if let Ok(val) = expr.replace('_', "").parse::<f32>() {
        return val;
    }

    // Try looking up as a constant reference
    if let Some(ref_expr) = constants.get(expr) {
        return eval_f32_expr(constants, ref_expr);
    }

    panic!("Could not evaluate f32 expression: {}", expr);
}

/// Try to evaluate an expression as usize, returning Err if it's not a usize expression
fn try_eval_usize_expr(constants: &HashMap<String, String>, expr: &str) -> Result<usize, ()> {
    let expr = expr.trim();

    // Handle parenthesized expressions
    if expr.starts_with('(') && expr.ends_with(')') {
        let inner = &expr[1..expr.len() - 1];
        if is_balanced_parens(inner) {
            return try_eval_usize_expr(constants, inner);
        }
    }

    // Handle `as usize` casts
    if let Some(pos) = expr.rfind(" as usize") {
        let inner = expr[..pos].trim();
        // Inner is likely f32, evaluate and cast
        let val = eval_f32_expr(constants, inner);
        return Ok(val as usize);
    }

    // Handle binary operations
    if let Some((left, op, right)) = split_binary_op(expr) {
        let l = try_eval_usize_expr(constants, left)?;
        let r = try_eval_usize_expr(constants, right)?;
        return Ok(match op {
            '+' => l + r,
            '-' => l - r,
            '*' => l * r,
            '/' => l / r,
            _ => return Err(()),
        });
    }

    // Try parsing as a literal
    if let Ok(val) = expr.replace('_', "").parse::<usize>() {
        return Ok(val);
    }

    // Try looking up as a constant reference
    if let Some(ref_expr) = constants.get(expr) {
        return try_eval_usize_expr(constants, ref_expr);
    }

    Err(())
}

/// Evaluate a usize expression (panics on failure)
fn eval_usize_expr(constants: &HashMap<String, String>, expr: &str) -> usize {
    try_eval_usize_expr(constants, expr)
        .unwrap_or_else(|_| panic!("Could not evaluate usize expression: {}", expr))
}

/// Check if parentheses are balanced in a string
fn is_balanced_parens(s: &str) -> bool {
    let mut depth = 0i32;
    for c in s.chars() {
        match c {
            '(' => depth += 1,
            ')' => depth -= 1,
            _ => {}
        }
        if depth < 0 {
            return false;
        }
    }
    depth == 0
}

/// Split an expression on the lowest-precedence binary operator outside parentheses
/// For left-to-right associativity, we want the RIGHTMOST operator of lowest precedence
fn split_binary_op(expr: &str) -> Option<(&str, char, &str)> {
    let expr = expr.trim();
    let mut depth = 0;
    let mut best_pos = None;
    let mut best_precedence = 100;

    let bytes = expr.as_bytes();
    for (i, &b) in bytes.iter().enumerate() {
        match b {
            b'(' => depth += 1,
            b')' => depth -= 1,
            b'+' | b'-' if depth == 0 && i > 0 => {
                // Lower precedence = should be split first
                // Use >= to get rightmost for left-to-right associativity
                let prec = 1;
                if prec <= best_precedence {
                    best_precedence = prec;
                    best_pos = Some((i, b as char));
                }
            }
            b'*' | b'/' if depth == 0 => {
                // Use >= to get rightmost for left-to-right associativity
                let prec = 2;
                if prec <= best_precedence {
                    best_precedence = prec;
                    best_pos = Some((i, b as char));
                }
            }
            _ => {}
        }
    }

    best_pos.map(|(pos, op)| (&expr[..pos], op, &expr[pos + 1..]))
}
